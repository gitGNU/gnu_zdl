#!/bin/bash -i
#
# ZigzagDownLoader (ZDL)
# 
# This program is free software: you can redistribute it and/or modify it 
# under the terms of the GNU General Public License as published 
# by the Free Software Foundation; either version 3 of the License, 
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License 
# along with this program. If not, see http://www.gnu.org/licenses/. 
# 
# Copyright (C) 2012
# Free Software Foundation, Inc.
# 
# For information or to collaborate on the project:
# https://savannah.nongnu.org/projects/zdl
# 
# Gianluca Zoni (project administrator and first inventor)
# http://inventati.org/zoninoz
# zoninoz@inventati.org
#

path_usr="/usr/local/share/zdl"

source $path_usr/man.sh
source $path_usr/updater.sh
source $path_usr/config.sh
source $path_usr/config_manager.sh
source $path_usr/axel_installer.sh

source $path_usr/libs/common.sh
source $path_usr/libs/downloader_manager.sh
source $path_usr/libs/DLstdout_parser.sh
source $path_usr/libs/extension_utils.sh
source $path_usr/libs/firefox.sh
source $path_usr/libs/login.sh
source $path_usr/libs/ip_changer.sh
source $path_usr/libs/log.sh

source $path_usr/ui/widgets.sh
source $path_usr/ui/ui.sh


#### MAIN
init

## get config data
get_conf


args=( "$@" )
max_args=$(( ${#args[*]}-1 ))

if [ "${args[*]}" != "${args[*]//--silent}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == "--silent" ]; then
	    unset args[$i]
	    daemon="true"
	    sleeping_pause=10
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//$PWD}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == "$PWD" ]; then
	    unset args[$i]
	fi
    done
fi


## conkeror
if [ "${args[*]}" != "${args[*]//--zigzag-xterm}" ]; then
    if [ "$daemon" != "true" ]; then 
	if [ -z "$DISPLAY" ]; then
	    export DISPLAY=":0"
	fi
	url="${args[*]%'--zigzag-xterm'*}"
	parameters="${args[*]#*'--zigzag-xterm'}"
	parameters="${parameters%'--cwd'*}"
	if [ -e "/cygdrive" ]; then
	    dest_dir="${args[*]#*'--cwd'}"
	    dest_dir=$(cygpath -u "$dest_dir")
	    [ ! -z "$dest_dir" ] && cd "$dest_dir"
	fi
	# export pid_prog=$$
	# check_instance_prog
	# if [ "$?" == "1" ]; then
	#     links_loop + "$url"
	#     redirect_links
	if [ -e "/cygdrive" ]; then
	    $prog "$url" $parameters --stop
	else
	    xterm -tn "xterm-256color" -fa "XTerm*faceName: xft:Dejavu Sans Mono:pixelsize=12" +bdc -fg grey -bg black -title "ZigzagDownLoader in $PWD" -e "/bin/bash -i -c \"export pid_prog=\$$ ; zdl $parameters \\\"$url\\\" --stop \"" &
	fi
	exit
    else
	unset args
    fi
fi


if [ "${args[*]}" != "${args[*]//--stream}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == "--stream" ]; then 
	## zdl --stream [URL] [FNAME] [FOLDER] [CFILE] [COOKIE] [REFERER]
	## zdl --stream [URL] [FNAME] --noXterm
	    if [ -z "$DISPLAY" ]; then
		export DISPLAY=":0"
	    fi
	    url_in="$2"
	    url_in="${url_in// /20%}"
	    
	    test_dir_3="$3"
	    test_dir_4="$4"
	    if [ -e "/cygdrive" ]; then
		test_dir_3=$(cygpath -u "$test_dir_3")
		test_dir_4=$(cygpath -u "$test_dir_4")
	    fi
	    if [ ! -d "$test_dir_3" ]; then
		file_in="$test_dir_3"
		if [ "$test_dir_4" != "--noXterm" ] && [ -d "$test_dir_4" ]; then
		    directory="$test_dir_4"
		fi
	    else
		directory="$test_dir_3"
		unset file_in
	    fi

	    if [ "$file_in" != "${file_in//'/'/}" ]; then
		if [ -z "$directory" ]; then
		    directory="${file_in%/*}"
		fi
		file_in="${file_in##*/}"
	    fi
	    file_in="${file_in// /_}"
	    file_in="${file_in##*/}"
	    cfile="$5"
	    cookie="$6"
	    referer="$7"

	    if [ "$url_in" != "${url_in//nowvideo.}" ] && [ ! -e "/cygdrive" ]; then
		referer="$6"
		ext="${file_in##*.}"
		file_in2=`wget "$referer" -O - -q | grep "&amp;title="`
		file_in2="${file_in2#*'&amp;title='}"
		[ ! -z "$file_in2" ] && file_in2="${file_in2// /_}" && file_in="${file_in2%%\"*}.$ext"
	    fi

	    cd "$directory"
	    mkdir -p "${path_tmp}"
	    
	    if [ -e "$cfile" ]; then cat "$cfile" >> "$path_tmp/flashgot_cfile.zdl" ; fi
	    echo -e "$cookie" > "$path_tmp/flashgot_cookie.zdl"
	    
	    echo "$url_in" > "${path_tmp}/filename_${file_in}.txt" 
	    if [ "$4" == "--noXterm" ] || [ -e "/cygdrive" ]; then
		export pid_prog=$$
		check_instance_prog
		if [ "$?" == "1" ]; then
		    links_loop + "$url_in"
		    redirect_links
		else
		    $prog "$url_in" $stream_params
		    pause
		fi
	    else
		xterm -tn "xterm-256color" -fa "XTerm*faceName: xft:Dejavu Sans Mono:pixelsize=12" +bdc -fg grey -bg black -title "ZigzagDownLoader in $PWD" -e "/bin/bash -i -c \"export pid_prog=\$$ ; $prog \\\"$url_in\\\" $stream_params --stop\"" &
	    fi
	    unset args[$i]
	    exit
	fi
    done 
fi


if [ "${args[*]}" != "${args[*]//--stop}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == "--stop" ]; then 
	    unset args[$i]
	    xterm_stop=true
	fi
    done
fi


if [ "${args[*]}" != "${args[*]//--daemon}" ] || [ "${args[*]}" != "${args[*]//-d}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == "--daemon" ] || [ "${args[$i]}" == "-d" ]; then
	    unset args[$i]
	    check_instance_daemon
	    if [ $? != 1 ]; then
		rm -r "$path_tmp/lock.zdl"
		nohup /bin/bash $prog ${args[*]} --silent $PWD &>/dev/null &
		header_z
		print_c 1 "$PROG è stato avviato come demone: puoi controllarlo dalla stessa directory ($PWD) attraverso $PROG interactive --> \"$prog -i\"\n"
		mkdir -p "$path_tmp"
	    else
		header_z
		print_c 3 "Esiste già un'istanza attiva del demone di $PROG in $PWD\n"
		add=true
	    fi
	    for j in `seq 0 ${#args[*]}`; do
		if [ "${args[$j]}" == "${args[$j]#'-'}" ] && [ ! -e "${args[$j]}" ] && [ ! -z "${args[$j]}" ]; then
		    if [ "$add" == "true" ]; then
			touch "$path_tmp"/links_loop.txt
			links_loop + "${args[$j]}"
		    fi
		    new_links="${args[$j]}\n$new_links"
		fi
	    done
	    if [ ! -z "$new_links" ]; then
		header_box "Nuovi URL aggiunti in coda al demone:"
		echo -e "$new_links"
	    fi

	    [ ! -z "$xterm_stop" ] && xterm_stop
	    exit
	fi
    done
fi


export pid_prog=$$

if [ "${args[*]}" != "${args[*]//--help}" ] || [ "${args[*]}" != "${args[*]//-h}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == "--help" ] || [ "${args[$i]}" == "-h" ]; then 
	    unset args[$i]
	    usage
	fi
    done
fi

################################### HEADER
if [ ! -f "$path_conf/noclear" ]; then 
    fclear
else
    rm "$path_conf/noclear"
fi
header_z
###################################





if [ "${args[*]}" != "${args[*]//--update}" ] || [ "${args[*]}" != "${args[*]//-u}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--update' ] || [ "${args[$i]}" == '-u' ]; then
	    unset args[$i]
	    update
	fi
    done
elif [ "$autoupdate" == "enabled" ] && [ "${args[*]}" == "${args[*]//--interactive}" ] && [ "${args[*]}" == "${args[*]//-i}" ]; then
    update
fi


if [ "${args[*]}" != "${args[*]//--multi}" ] || [ "${args[*]}" != "${args[*]//-m}" ]; then 
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--multi' ] || [ "${args[$i]}" == '-m' ]; then 
	    unset args[$i]
	    multi=1
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--ip}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--ip' ]; then 
	    unset args[$i]
	    my_ip
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--login}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--login' ]; then 
	    unset args[$i]
	    login=1
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--interactive}" ] || [ "${args[*]}" != "${args[*]//-i}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--interactive' ] || [ "${args[$i]}" == '-i' ]; then 
	    unset args[$i]
	    interactive
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--wget}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--wget' ]; then 
	    unset args[$i]
	    downloader_in=Wget
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--axel}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--axel' ]; then 
	    unset args[$i]
	    downloader_in=Axel
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--clean}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == '--clean' ]; then 
	    unset args[$i]
	    ( rm -r "$path_tmp"/* 2>/dev/null && print_c 1 "File temporanei cancellati" ) || ( print_c 3 "Pulizia file temporanei non effettuata (file inesistenti)" )
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--configure}" ] || [ "${args[*]}" != "${args[*]//-c}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" == "--configure" ] || [ "${args[$i]}" == "-c" ]; then 
	    unset args[$i]
	    configure
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--out=}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" != "${args[$i]#'--out='}" ]; then
	    if [ -e "$(which $(echo ${args[$i]#'--out='} | awk '{print $1}') )" ]; then
		pipe_out="${args[$i]#'--out='}"
	    else
		print_c 3 "Il file in ${args[$i]} non esiste"
		print_c 2 "Scrivo in ${args[$i]#'--out='}.txt la lista dei file scaricati? (s|*)"
		read -n 1 option_out
		if [ "$option_out" == "s" ]; then
		    print_out="${args[$i]#'--out='}"
		    print_c 1 "\n\nLa lista dei file verrà salvata in $print_out\n(puoi anche usarla per comunicare i file in scaricamento a un altro programma)\n"
		    unset option_out
		fi
	    fi
	    unset args[$i]
	fi
    done
fi

if [ "${args[*]}" != "${args[*]//--proxy}" ]; then
    for i in `seq 0 $max_args`; do
	if [ "${args[$i]}" != "${args[$i]#'--proxy'}" ]; then
	    
	    if [ "${args[$i]}" == '--proxy' ]; then
		update_proxy=true
		unset args[$i]
		break
	    elif [ "${args[$i]}" == '--proxy=t' ]; then
		proxy_types[${#proxy_types[*]}]="Transparent"
		update_proxy=true
	    elif [ "${args[$i]}" == '--proxy=a' ]; then
		proxy_types[${#proxy_types[*]}]="Anonymous"
		update_proxy=true
	    elif [ "${args[$i]}" == '--proxy=e' ]; then
		proxy_types[${#proxy_types[*]}]="Elite"
		update_proxy=true
	    elif [ "${args[$i]}" != "${args[$i]%'='*}" ]; then
		proxy="${args[$i]#'--proxy='}"
		if [ -z "${proxy//[0-9.:]}" ]; then
		    export http_proxy=$proxy
		    defined_proxy=$proxy
		    print_c 1 "Proxy attivo: $http_proxy"
		    update_defined_proxy=true
		    unset update_proxy
		else
		    print_c 3 "${args[$i]}: argomento non valido"
		    echo
		    usage
		fi
	    else
		print_c 3 "${args[$i]}: argomento non valido"
		echo
		usage
	    fi
	    unset args[$i]
	fi
    done
fi

for i in `seq 0 $max_args`; do
    if [ "${args[$i]}" != "${args[$i]#-}" ]; then
	print_c 3 "${args[$i]}: argomento non valido"
	echo
	usage
    fi
done

if [ ! -z "${args[*]}" ]; then
    COOKIE="$path_tmp/flashgot_cfile.zdl"
    while true; do
	for i in `seq 0 $max_args`; do
	    if [ -f "${args[$i]}" ]; then
		links=`cat "${args[$i]}"` 
		echo -e "${links// /%20}" >> "$path_tmp"/links_loop.txt
	    elif [ ! -z "${args[$i]}" ]; then
		echo -e "${args[$i]// /%20}" >> "$path_tmp"/links_loop.txt
		links="${links}\n${args[$i]// /%20}"
	    fi
	done
	if [ -f "$path_tmp"/links_loop.txt ];then 
	    file="$path_tmp/links_loop.txt"
	    clean_file "$path_tmp"/links_loop.txt
	    echo >> links.txt 2>/dev/null
	    date >> links.txt 2>/dev/null
	    cat "$path_tmp"/links_loop.txt >> links.txt 2>/dev/null
	    print_c 1 "L'elenco completo dei link è in links.txt"
	    break
	fi
    done
fi

###########################################
## FLASHGOT AVVIO CONFIGURAZIONE AUTOMATICA
##
# local_version=`cat "$path_conf/version.txt" 2>/dev/null`
# num1=${local_version//*[.,]}
# num2=${local_version//[.,]*}
# if [ -f "$path_conf/flashgot_updated" ] || ( [ -f "$path_conf/updated" ] && (( $num1<$version_ffprefs_new )) ); then
#     if [ "$flashgot" == "enabled" ];then
# 	flashgot_autoconf
#     elif [ "$flashgot" != "enabled" ];then
# 	restore_ffprefs
#     fi
# fi
# rm -f "$path_conf/updated" "$path_conf/flashgot_updated"
###########################################


echo -e "\n${BBlue}Downloader:${Color_Off} $downloader_in\t${BBlue}Directory:${Color_Off} $PWD\n"

if [ -f "$file_log" ]; then
    log=1
fi


if [ -z "$file" ] && [ "$daemon" != "true" ]; then
    check_instance_prog
    if [ "$?" != "1" ]; then
	echo "$pid_prog" > "$path_tmp/pid.zdl"
    fi
    if [ -z "$pipe" ]; then
	header_box "Links"
	header_dl "Servizi"
	echo -e "${BBlue}Video in streaming saltando il player del browser:${Color_Off}\nVimeo (HD), Putlocker (HD), Youtube, Dailymotion, Metacafe, Topvideo, Rai.tv, Portalevideo.unimi.it\n\n${BBlue}File hosting (link della prima pagina web, anche da Italiafilm):${Color_Off}\nPutlocker, Nowdownload, Likeupload, Rapidshare, Cyberlocker, Tusfiles, BillionUploads, Glumbouploads, Mediafire, Uload, Easybytez e, dopo aver risolto il captcha e generato il link, anche Sharpfile, Depositfiles ed altri servizi\n\n${BBlue}Tutti i file scaricabili con le seguenti estensioni dei browser:${Color_Off}\nFlashgot (Firefox/Iceweasel/Icecat), Download Assistant e Simple get (Chrome/Chromium)\n" 
	header_dl "Comandi"
	echo -e "<${BGreen} @ ${Color_Off}>\t\tavvia nuovi download (prima incolla qua sotto i link, andando a capo dopo ciascuno)"
	echo -e "<${BGreen} @ ${Color_Off}>\t\trecupera i download lasciati in sospeso"
	echo -e "\n<${BYellow} i ${Color_Off}>\t\tmodalità interattiva (attivo dopo ${BGreen}@${Color_Off})"
	echo -e "<${BRed} q ${Color_Off}>\t\tuscita da ZDL (attivo dopo ${BGreen}@${Color_Off})"
	echo -e "<${BRed} Ctrl+c ${Color_Off}>\ttermina ZDL e i download di Axel (attivo anche ora)"
	separator-
	echo
    else
	print_c 3 "Le funzioni interattive non sono disponibili in questa istanza del programma, perché lo standard input è una PIPE. Puoi avviare l'interfaccia interattiva in questa stessa directory da un altro terminale\n"
    fi
    read -d @ links
    
    if [ -f "$path_tmp/rewriting" ];then
	while [ -f "$path_tmp/rewriting" ]; do
	    sleeping 0.1
	done
    fi
    touch "$path_tmp/rewriting"
    echo -e "${links// /%20}" >> "$path_tmp"/links_loop.txt
    file="$path_tmp/links_loop.txt"
    if [ -f "$file" ];then
	rm -f "$path_tmp/rewriting"
	clean_file "$file"
	if [ -f "$path_tmp/rewriting" ];then
	    while [ -f "$path_tmp/rewriting" ]; do
		sleeping 0.1
	    done
	fi
	touch "$path_tmp/rewriting"
	if [ -f "$file" ];then
	    cat $file >> links.txt
	    rm -f "$path_tmp/rewriting"
	else
	    rm -f "$path_tmp/rewriting"
	    
	    if [ "$daemon" != "true" ]; then
		print_c 3 "$name_prog: nessun link da processare in $PWD"
		rm -r "$path_tmp"
		exit
	    fi
	fi
	echo
    else
	rm -f "$path_tmp/rewriting"
    fi
fi

##converti UL.TO in UPLOADED.TO/FILE --> FROZEN
# if [ -f $file ]; then
# 	lnks=`cat $file`
# 	rm $file
# 	
# 	echo -e "${lnks// /\n}" | while read line ; do 
# 		if [ "$line" != "${line//http:\/\/ul.to/}" ]; then
# 			line=${line//ul.to/uploaded.to/file}
# 			
# 			
# 		fi
# 		echo $line >> $file
# 	done
# 	init_links_loop
# fi
##

check_instance_prog
if [ "$?" == "1" ]; then
    redirect_links
fi

check_instance_daemon
if [ $? == 1 ]; then
    redirect_links
fi

echo "$pid_prog" > "$path_tmp/pid.zdl"
rm -f "$path_tmp/lock.zdl"


while true; do
    if [ "$daemon" == "true" ] && [ ! -f "$file" ]; then
	file="$path_tmp/links_loop.txt"
	sleeping 5
    elif [ -f "$file" ]; then

	links_in=`cat $file`
	for url_in in $links_in; do

	    echo -e "${BBlue}checking $url_in ...${Color_Off}"
	    unset pid_in checked file_in url_in_file
	    check_in_url
	    if [ $? != 1 ];then
		axel_parts=$axel_parts_conf
		url_in="${url_in## }"
		url_in="${url_in%% }"

		## user extensions
		if [ -d "$path_conf/extensions/" ]; then
		    shopt -s nullglob
		    for srcfile in "$path_conf"/extensions/*.sh; do
			source "$srcfile"
		    done
		    shopt -u nullglob
		fi
		##################

		if [ "$update_proxy" == "true" ];then
		    unset newip update_proxy
		    new_ip_proxy
		    update_proxy_others="true"
		elif [ "$update_defined_proxy" == "true" ];then
		    export http_proxy=$defined_proxy
		fi
		
		echo > "$path_tmp"/zdl.tmp > "$path_tmp"/zdl2.tmp
		
		echo
		header_box "Link da processare:"
		echo -e "$url_in\n"

		## PROG extensions
		if [ -d "$path_usr/extensions/" ]; then
		    shopt -s nullglob
		    for srcfile in "$path_usr"/extensions/*.sh; do
			source "$srcfile"
		    done
		    shopt -u nullglob
		fi
		###################
		
		if [ -z "$file_in" ] || [ -z "$url_in_file" ]; then
		    if [ "$update_proxy_others_list" == "true" ]; then
			new_ip_proxy
		    fi
		    
		    data_stdout
		    if [ $? == 1 ]; then 
			last_out=$(( ${#pid_out[*]}-1 ))
			for j in `seq 0 $last_out`; do
			    if [ "$url_in" == "${url_out[$j]}" ]; then
				file_in="${file_out[$j]}"
				break
			    fi
			done
		    fi	
		 
		## streaming downloader
		    items=( `ls "$path_tmp"/filename_* 2>/dev/null` )
		    if [ ! -z "${items[*]}" ]; then
			
			for item in ${items[*]}; do
			    url=`cat "$item"`
			    if [ "${url%% }" == "$url_in" ]; then
				item="${item// /_}"
				file_in="${item#*filename_}"
				file_in="${file_in%.txt}"
				break
			    fi
			done
		    fi
		    
		## universal downloader
		    if [ -z "$file_in" ]; then
			
			file_in="${url_in##*'/'}"
			file_in="${file_in%'?'*}"
			
		    fi
		    url_in_file="${url_in%% }"
		    url_in_file="${url_in_file## }"
		    
		    if [ "$update_proxy_others" == "true" ]; then
			update_proxy_others_list="true"
		    fi
		    
		fi
		if [ "$url_in_file" == "${url_in_file//nowvideo.}" ]; then
		    axel_parts=8
		fi

		
		file_in="${file_in// /_}"
		file_in="${file_in//\'/_}"
		file_in="${file_in##*/}"

       		#### CHECK $url_in_file & $file_in:

		check_freespace
		test_freespace=$?
		check_in_file
		test_in=$?
		[ "$test_freespace" == "1" ] && unset test_in test_freespace
		
		#### DOWNLOAD ####
		if [ "$test_in" == "5" ] && [ -z "$premium" ]; then
		    unset test_in
		    download || usage
		    check_pid ${pid_in}
		    if [ $? == 1 ]; then
			print_c 1 "downloading --> $file_in ..."
		    fi
		    
		    while true; do
			show_downloads
			check_download
			if [ $? == 1 ]; then
			    break
			fi
			check_pid ${pid_in}
			if [ $? != 1 ]; then
			    break
			fi
		    done
		    rm -f "$path_tmp/cookies.zdl"
		    unset no_newip
		    check_freespace
		    check_alias
		else
		    sleeping 1
		fi
		
		if [ ! -f "$path_tmp/${file_in}_stdout.tmp" ] && [ -f "${file_in}" ] && [ ! -f "${file_in}.st" ]; then
		    links_loop - "$url_in"
		fi

		newip_add_provider
		from_loop=true
		[ "$ch_dler" == "1" ] && downloader_in=$dler && unset ch_dler
		unset checked
		noproxy

		if [ "$multi" == "1" ]; then
		    check_stdout
		    show_downloads
		    checked=1
		fi
		while [ "$checked" != "1" ]; do #file_in
		    check_stdout
		    show_downloads
		    check_pid $pid_in
		    test_pid=$?
		    
		    links_loop "in" "$url_in"
		    test_loop_in=$?
		    if [ $test_loop_in != 1 ] || [ $test_pid != 1 ]; then 
			checked=1
		    fi
		    pipe_files
		done
		
		unset checked
		unset post_data goal not_available exceeded
	    fi
	done
	pipe_files
	if [ -f "$path_tmp/links_loop.txt" ]; then
	    file="$path_tmp/links_loop.txt"
	fi
	check_stdout
	[ -z "$no_msg" ] && show_downloads
	unset test_pids
	data_stdout
	if [ $? == 1 ]; then
	    last_stdout=$(( ${#pid_out[*]}-1 ))
	    for i in `seq 0 $last_stdout`; do
		check_pid "${pid_out[$i]}"
		test_pids=$?
		[ "$test_pids" == "1" ] && break
	    done
	fi
	unset no_msg
	[ ! -f "$path_tmp/links_loop.txt" ] && [ "$test_pids" != "1" ] && [ "$daemon" != "true" ] && break
    else 
	usage
	exit
    fi
done
rm -f "$path_tmp/lock.zdl"
noproxy

separator "─"
print_c 1 "Download completato"
separator "─"

if [ ! -z "$pipe_out" ] && [ "$pipe_done" != 1 ]; then
    data_stdout
    pipe_files
fi

check_instance_dl
if [ "$?" != "1" ] || [ ! -f "$path_tmp/lock.zdl" ]; then
    rm -r "$path_tmp" 2>/dev/null
fi

echo
echo
if [ -f "$file_log" ]; then
    print_c 3 "In questa directory è presente un file che contiene un elenco di operazioni di $PROG terminate senza successo."
    echo -e "Per leggerlo, digita:\n\n cat $file_log\n\n"
fi

if [ "$xterm_stop" == "true" ]; then
    xterm_stop
fi
echo -e -n "\e[0m\e[J"

